# file opened: download.asm
  1   0000              ;==================================================================================
  2   0000              ; Contents of this file are copyright Grant Searle
  3   0000              ; HEX routine from Joel Owens.
  4   0000              ;
  5   0000              ; You have permission to use this for NON COMMERCIAL USE ONLY
  6   0000              ; If you wish to use it elsewhere, please include an acknowledgement to myself.
  7   0000              ;
  8   0000              ; http://searle.hostei.com/grant/index.html
  9   0000              ;
 10   0000              ; eMail: home.micros01@btinternet.com
 11   0000              ;
 12   0000              ; If the above don't work, please perform an Internet search to see if I have
 13   0000              ; updated the web page hosting service.
 14   0000              ;
 15   0000              ;==================================================================================
 16   0000
 17   0000              TPA	.EQU	100H
 18   0000              REBOOT	.EQU	0H
 19   0000              BDOS	.EQU	5H
 20   0000              CONIO	.EQU	6
 21   0000              CONINP	.EQU	1
 22   0000              CONOUT	.EQU	2
 23   0000              PSTRING	.EQU	9
 24   0000              MAKEF	.EQU	22
 25   0000              CLOSEF	.EQU	16
 26   0000              WRITES	.EQU	21
 27   0000              DELF	.EQU	19
 28   0000              SETUSR	.EQU	32
 29   0000
 30   0000              CR	.EQU	0DH
 31   0000              LF	.EQU	0AH
 32   0000
 33   0000              FCB	.EQU	05CH
 34   0000              BUFF	.EQU	080H
 35   0000
 36   0000              	.ORG TPA
 37   0100
 38   0100              ; Zero out the variables
 39   0100 3E 00        	LD	A,0
 40   0102 32 91 02     	LD	(buffPos),A
 41   0105 32 95 02     	LD	(checkSum),A
 42   0108 32 96 02     	LD	(byteCount),A
 43   010B 32 94 02     	LD	(printCount),A
 44   010E 21 80 00     	LD	HL,BUFF
 45   0111 22 92 02     	LD	(buffPtr),HL
 46   0114
 47   0114
 48   0114 CD 5D 02     WAITLT:	CALL	GETCHR
 49   0117 FE 55        	CP	'U'
 50   0119 CA 4E 02     	JP	Z,SETUSER
 51   011C FE 3A        	CP	':'
 52   011E 20 F4        	JR	NZ,WAITLT
 53   0120
 54   0120              	; Remove any pre-existing file by this name
 55   0120 0E 13        	LD	C,DELF
 56   0122 11 5C 00     	LD	DE,FCB
 57   0125 CD 05 00     	CALL	BDOS
 58   0128
 59   0128              	; Create the new file
 60   0128 0E 16        	LD	C,MAKEF
 61   012A 11 5C 00     	LD	DE,FCB
 62   012D CD 05 00     	CALL	BDOS
 63   0130
 64   0130              	; Print out starting message
 65   0130 11 D3 02     	LD	DE,processMess
 66   0133 0E 09        	LD	C,PSTRING
 67   0135 CD 05 00     	CALL	BDOS
 68   0138
 69   0138 06 0B        	LD B,11   ; There are 11 max bytes in the filename
 70   013A 21 5C 00     	LD HL,FCB ; Start from FCB (will be pre-incremented)
 71   013D
 72   013D
 73   013D              ; Print out the filename we're using
 74   013D              PRINTFNAME:
 75   013D 23           	INC  HL			; Starting from 1 and then incrementing from there
 76   013E 5E           	LD   E,(HL)		; Store value at IX into E
 77   013F 0E 02        	LD   C,CONOUT	; Prepare to call CONOUT in BDOS
 78   0141 C5           	PUSH BC
 79   0142 E5           	PUSH HL
 80   0143 CD 05 00     	CALL BDOS		; Call CONOUT
 81   0146 E1           	POP  HL
 82   0147 C1           	POP  BC			; Restore some registers
 83   0148 10 F3        	DJNZ PRINTFNAME ; Decrement B compare to 0. If ne 0 jump to PRINTFNAME
 84   014A 3E 0D        	LD   A,"\r"
 85   014C CD 69 02     	CALL PUTCHR
 86   014F 3E 0A        	LD   A,"\n"
 87   0151 CD 69 02     	CALL PUTCHR
 88   0154
 89   0154
 90   0154              ; Read a hex value from input and possibly write to disk once decoded and the
 91   0154              ; buffer is full (128 bytes)
 92   0154              GETHEX:
 93   0154 CD 5D 02     	CALL 	GETCHR ; Load the first byte
 94   0157 FE 3E        	CP	'>'        ; Is it the ending sequence?
 95   0159 28 61        	JR	Z,CLOSE    ; If so, close out
 96   015B 47           	LD   B,A       ; Otherwise put in B
 97   015C C5           	PUSH BC        ; Store BC on the stack
 98   015D CD 5D 02     	CALL GETCHR    ; Get the next char
 99   0160 C1           	POP BC         ; Load up BC from the stack
100   0161 4F           	LD   C,A       ; Store A into C
101   0162
102   0162 CD 70 02     	CALL BCTOA     ; Convert two ASCII hex bytes to 1 byte
103   0165
104   0165 47           	LD	B,A           ; Store our read byte into B
105   0166 3A 95 02     	LD	A,(checkSum)  ; Load up the checksum
106   0169 80           	ADD	A,B           ; Add them
107   016A 32 95 02     	LD	(checkSum),A  ; Store the result into the checksum
108   016D 3A 96 02     	LD	A,(byteCount) ; Load up the byteCount
109   0170 3C           	INC	A             ; Increment it
110   0171 32 96 02     	LD	(byteCount),A ; Store into byteCount
111   0174
112   0174 78           	LD	A,B           ; Load B into A
113   0175
114   0175 2A 92 02     	LD	HL,(buffPtr)  ; Load buffPtr into HL
115   0178
116   0178 77           	LD	(HL),A        ; Store our read byte into buffPtr
117   0179 23           	INC	HL            ; Move the HL one to the right
118   017A 22 92 02     	LD	(buffPtr),HL  ; Update buffPtr to address from HL
119   017D
120   017D 3A 91 02     	LD	A,(buffPos)   ; Load A with buffPos
121   0180 3C           	INC	A             ; Increment A
122   0181 32 91 02     	LD	(buffPos),A   ; Store A back to buffPos
123   0184 FE 80        	CP	80H           ; Is buffPos/A 128?
124   0186
125   0186 20 32        	JR	NZ,NOWRITE    ; If not, jump to NOWRITE
126   0188
127   0188 0E 15        	LD	C,WRITES      ; Load WRITES into C
128   018A 11 5C 00     	LD	DE,FCB        ; Load up DE with FCB
129   018D CD 05 00     	CALL	BDOS        ; Call BDOS to write to file
130   0190 3E 2E        	LD	A,'.'         ; Load '.' into A
131   0192 CD 69 02     	CALL	PUTCHR      ; Output it to the terminal
132   0195
133   0195                  ; New line every 8K (64 dots)
134   0195 3A 94 02     	LD	A,(printCount)
135   0198 3C           	INC	A
136   0199 FE 40        	CP	64
137   019B 20 0F        	JR	NZ,noCRLF
138   019D 32 94 02     	LD	(printCount),A
139   01A0 3E 0D        	LD	A,CR
140   01A2 CD 69 02     	CALL	PUTCHR
141   01A5 3E 0A        	LD	A,LF
142   01A7 CD 69 02     	CALL	PUTCHR
143   01AA 3E 00        	LD	A,0
144   01AC 32 94 02     noCRLF:	LD	(printCount),A
145   01AF
146   01AF 21 80 00     	LD	HL,BUFF
147   01B2 22 92 02     	LD	(buffPtr),HL
148   01B5
149   01B5 3E 00        	LD	A,0
150   01B7 32 91 02     	LD	(buffPos),A
151   01BA              NOWRITE:
152   01BA 18 98        	JR	GETHEX
153   01BC
154   01BC
155   01BC              CLOSE:
156   01BC
157   01BC 3A 91 02     	LD	A,(buffPos)
158   01BF FE 00        	CP	0
159   01C1 28 0D        	JR	Z,NOWRITE2
160   01C3
161   01C3 0E 15        	LD	C,WRITES
162   01C5 11 5C 00     	LD	DE,FCB
163   01C8 CD 05 00     	CALL	BDOS
164   01CB 3E 2E        	LD	A,'.'
165   01CD CD 69 02     	CALL	PUTCHR
166   01D0
167   01D0              NOWRITE2:
168   01D0 0E 10        	LD	C,CLOSEF
169   01D2 11 5C 00     	LD	DE,FCB
170   01D5 CD 05 00     	CALL	BDOS
171   01D8
172   01D8              ; Byte count (lower 8 bits)
173   01D8 CD 5D 02     	CALL 	GETCHR
174   01DB 47           	LD   B,A
175   01DC C5           	PUSH BC
176   01DD CD 5D 02     	CALL GETCHR
177   01E0 C1           	POP BC
178   01E1 4F           	LD   C,A
179   01E2
180   01E2 CD 70 02     	CALL BCTOA
181   01E5 47           	LD	B,A
182   01E6 3A 96 02     	LD	A,(byteCount)
183   01E9 90           	SUB	B
184   01EA FE 00        	CP	0
185   01EC 28 1A        	JR	Z,byteCountOK
186   01EE
187   01EE 3E 0D        	LD	A,CR
188   01F0 CD 69 02     	CALL	PUTCHR
189   01F3 3E 0A        	LD	A,LF
190   01F5 CD 69 02     	CALL	PUTCHR
191   01F8
192   01F8 11 B5 02     	LD	DE,countErrMess
193   01FB 0E 09        	LD	C,PSTRING
194   01FD CD 05 00     	CALL	BDOS
195   0200
196   0200              	; Sink remaining 2 bytes
197   0200 CD 5D 02     	CALL GETCHR
198   0203 CD 5D 02     	CALL GETCHR
199   0206
200   0206 18 3C        	JR	FINISH
201   0208
202   0208              byteCountOK:
203   0208
204   0208              ; Checksum
205   0208 CD 5D 02     	CALL 	GETCHR   ; Get a character
206   020B 47           	LD   B,A         ; Store A into B
207   020C C5           	PUSH BC          ; Push BC onto the stack
208   020D CD 5D 02     	CALL GETCHR      ; Get second character
209   0210 C1           	POP BC           ; Get BC off the stack
210   0211 4F           	LD   C,A         ; Copy A to C
211   0212
212   0212 CD 70 02     	CALL BCTOA       ; Decode hex into A
213   0215 47           	LD	B,A          ; Store the byte into B
214   0216 3A 95 02     	LD	A,(checkSum) ; Put current checksum into A
215   0219 90           	SUB	B            ; Subtract byte we read
216   021A FE 00        	CP	0            ; Was it 0?
217   021C 28 14        	JR	Z,checksumOK ; If so, it's good
218   021E
219   021E 3E 0D        	LD	A,CR
220   0220 CD 69 02     	CALL	PUTCHR
221   0223 3E 0A        	LD	A,LF
222   0225 CD 69 02     	CALL	PUTCHR
223   0228
224   0228 11 9A 02     	LD	DE,chkErrMess
225   022B 0E 09        	LD	C,PSTRING
226   022D CD 05 00     	CALL	BDOS
227   0230 18 12        	JR	FINISH
228   0232
229   0232              checksumOK:
230   0232 3E 0D        	LD	A,CR
231   0234 CD 69 02     	CALL	PUTCHR
232   0237 3E 0A        	LD	A,LF
233   0239 CD 69 02     	CALL	PUTCHR
234   023C
235   023C 11 97 02     	LD	DE,OKMess
236   023F 0E 09        	LD	C,PSTRING
237   0241 CD 05 00     	CALL	BDOS
238   0244
239   0244
240   0244
241   0244              FINISH:
242   0244 0E 20        	LD	C,SETUSR
243   0246 1E 00        	LD	E,0
244   0248 CD 05 00     	CALL	BDOS
245   024B
246   024B C3 00 00     	JP	REBOOT
247   024E
248   024E
249   024E              SETUSER:
250   024E CD 5D 02     	CALL	GETCHR
251   0251 CD 89 02     	CALL	HEX2VAL
252   0254 5F           	LD	E,A
253   0255 0E 20        	LD	C,SETUSR
254   0257 CD 05 00     	CALL	BDOS
255   025A C3 14 01     	JP	WAITLT
256   025D
257   025D
258   025D              ; Get a char into A
259   025D              ;GETCHR: LD C,CONINP
260   025D              ;	CALL BDOS
261   025D              ;	RET
262   025D
263   025D              ; Wait for a char into A (no echo)
264   025D              GETCHR:
265   025D 1E FF        	LD	E,$FF
266   025F 0E 06        	LD 	C,CONIO
267   0261 CD 05 00     	CALL 	BDOS
268   0264 FE 00        	CP	0
269   0266 28 F5        	JR	Z,GETCHR
270   0268 C9           	RET
271   0269
272   0269              ; Write A to output
273   0269 0E 02        PUTCHR: LD C,CONOUT
274   026B 5F           	LD E,A
275   026C CD 05 00     	CALL BDOS
276   026F C9           	RET
277   0270
278   0270
279   0270              ;------------------------------------------------------------------------------
280   0270              ; Convert ASCII characters in B C registers to a byte value in A
281   0270              ;------------------------------------------------------------------------------
282   0270 78           BCTOA	LD   A,B	; Move the hi order byte to A
283   0271 D6 30        	SUB  $30	    ; Take it down from Ascii
284   0273 FE 0A        	CP   $0A	    ; Are we in the 0-9 range here?
285   0275 38 02        	JR   C,BCTOA1	; If so, get the next nybble
286   0277 D6 07        	SUB  $07	    ; But if A-F, take it down some more
287   0279 07           BCTOA1	RLCA		; Rotate the nybble from low to high
288   027A 07           	RLCA		    ; One bit at a time
289   027B 07           	RLCA		    ; Until we
290   027C 07           	RLCA		    ; Get there with it
291   027D 47           	LD   B,A	    ; Save the converted high nybble
292   027E 79           	LD   A,C	    ; Now get the low order byte
293   027F D6 30        	SUB  $30	    ; Convert it down from Ascii
294   0281 FE 0A        	CP   $0A	    ; 0-9 at this point?
295   0283 38 02        	JR   C,BCTOA2	; Good enough then, but
296   0285 D6 07        	SUB  $07	    ; Take off 7 more if it's A-F
297   0287 80           BCTOA2	ADD  A,B	; Add in the high order nybble
298   0288 C9           	RET
299   0289
300   0289              ; Change Hex in A to actual value in A
301   0289 D6 30        HEX2VAL SUB	$30
302   028B FE 0A        	CP	$0A
303   028D D8           	RET	C
304   028E D6 07        	SUB	$07
305   0290 C9           	RET
306   0291
307   0291
308   0291 00           buffPos	.DB	0H
309   0292 00 00        buffPtr	.DW	0000H
310   0294 00           printCount .DB	0H
311   0295 00           checkSum .DB	0H
312   0296 00           byteCount .DB	0H
313   0297 4F 4B 24     OKMess	.BYTE	"OK$"
314   029A 3D 3D 3D 3D  chkErrMess .BYTE	"======Checksum Error======$"
314   029E 3D 3D 43 68
314   02A2 65 63 6B 73
314   02A6 75 6D 20 45
314   02AA 72 72 6F 72
314   02AE 3D 3D 3D 3D
314   02B2 3D 3D 24
315   02B5 3D 3D 3D 3D  countErrMess .BYTE	"======File Length Error======$"
315   02B9 3D 3D 46 69
315   02BD 6C 65 20 4C
315   02C1 65 6E 67 74
315   02C5 68 20 45 72
315   02C9 72 6F 72 3D
315   02CD 3D 3D 3D 3D
315   02D1 3D 24
316   02D3 50 72 6F 63  processMess .BYTE "Processing file: $"
316   02D7 65 73 73 69
316   02DB 6E 67 20 66
316   02DF 69 6C 65 3A
316   02E3 20 24
317   02E5              	.END
# file closed: download.asm
